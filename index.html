<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>little Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="little Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="little Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Yang Nan">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="little Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/plugin/bganimation/bg.css">

  

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <div class="outer">
        <div class="widget-wrap mobile-header">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="https://wx4.sinaimg.cn/large/a3ba40b9ly1gbifs44zi0j20p00p0ac3.jpg">
    <h2 class="author">Yang Nan</h2>
    <h3 class="description"></h3>
    <div class="count-box">
      <a href="/archives"><div><strong>18</strong><br>文章</div></a>
      <a href="/categories"><div><strong>4</strong><br>分类</div></a>
      <a href="/tags"><div><strong>6</strong><br>标签</div></a>
    </div>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/categories" title="Categories">
            <li>分类</li>
          </a>
        
          <a href="/tags" title="Tags">
            <li>标签</li>
          </a>
        
    </ul>
  </div>
</div>

        <section id="main">
  
    <article id="post-机器学习1" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A01/" class="article-date">
  <time class="post-time" datetime="2020-03-04T06:47:53.784Z" itemprop="datePublished">
    <span class="post-month">3月</span><br/>
    <span class="post-day">04</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A01/">机器学习1</a>
    </h1>
  

        <div>
          
          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A01/" data-id="ck7eqa12t0000rkubgxnt1gdt" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-Java网络" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/01/Java%E7%BD%91%E7%BB%9C/" class="article-date">
  <time class="post-time" datetime="2020-03-01T14:41:47.733Z" itemprop="datePublished">
    <span class="post-month">3月</span><br/>
    <span class="post-day">01</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/01/Java%E7%BD%91%E7%BB%9C/">Java网络</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Java网络编程"><a href="#Java网络编程" class="headerlink" title="Java网络编程"></a>Java网络编程</h1><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><ul>
<li><p>规则:</p>
<ol>
<li>先通过IP找到对方</li>
<li>通过逻辑端口找到对应的应用程序</li>
<li>使用定义通信规则(协议)[UDP/TCP]</li>
</ol>
</li>
<li><p>网络模型</p>
<ul>
<li>OSI参考模型(八层)</li>
<li>TCP/IP参考模型(四层)</li>
</ul>
</li>
<li><p>Socket</p>
<ul>
<li>网络通信两端都有Socket</li>
<li>网络通信其实就是Socket间的通信</li>
<li>数据在两个Socket间通过IO传输</li>
<li>这里的Socket并不是计算机网络TCP中特指的Socket</li>
</ul>
</li>
<li><p>UDP与TCP的不同</p>
<p><img src="D:%5Cblog%5Csource%5Casset%5Cudp%E5%92%8Ctcp%E5%8C%BA%E5%88%AB.jpg" alt=""></p>
</li>
<li><p>所用到的包java.net</p>
</li>
</ul>
<h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><ol>
<li>IP地址对应对象(InetAddress)<ul>
<li>方法<ul>
<li><code>public static InetAddress getByName(String host)</code>在给定主机名的情况下确定主机的 IP 地址。</li>
<li><code>public static InetAddress[] getAllByName(String host)</code>在给定主机名的情况下，根据系统上配置的名称服务返回其 IP 地址所组成的数组。</li>
<li><code>public String getHostAddress()</code>返回 IP 地址字符串（以文本表现形式）。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>2.UDP(对讲机/寄邮件)相关对象</p>
<pre><code>1. DatagramSocket
+ 此类表示用来发送和接收数据报包的套接字。
+ `public DatagramSocket(int port)`创建数据报套接字并将其绑定到本地主机上的指定端口
+ `void send(DatagramPacket p)`从此套接字发送数据报包。
+ `void receive(DatagramPacket p)`从此套接字接收数据报包。接收一条就结束</code></pre><ol start="2">
<li><p>DatagramPacket(数据包)</p>
<ul>
<li>此类表示数据报包。</li>
<li><code>public DatagramPacket(byte[] buf,int length)</code>构造 DatagramPacket，用来接收长度为 length 的数据包。 </li>
<li><code>public DatagramPacket(byte[] buf,int length,InetAddress address,int port)</code>构造数据报包，用来将长度为 length 的包发送到指定主机上的指定端口号。               </li>
<li><code>public byte[] getData()</code>返回数据。</li>
<li><code>public InetAddress getAddress()</code>:返回IP地址</li>
</ul>
</li>
<li><p>TCP(打电话)相关对象</p>
<ul>
<li>客户端/服务端</li>
</ul>
<ol>
<li><p>Socket(客户端/服务端使用)</p>
<ul>
<li>建立时就可以去连接指定主机</li>
<li><code>public Socket(String host,int port)</code>创建一个流套接字并将其连接到指定主机上的指定端口号。</li>
<li><code>public OutputStream getOutputStream()</code>返回此套接字的输出流。</li>
<li><code>public void shutdownOutput()</code>:禁用此套接字的输出流。对于 TCP 套接字，任何以前写入的数据都将被发送，并且后跟 TCP 的正常连接终止序列(结束标记)。用于结束文件传输</li>
</ul>
</li>
<li><p>class ServerSocket(服务端)</p>
<ul>
<li><p><code>public ServerSocket(int port)</code>创建绑定到特定端口的服务器套接字。</p>
</li>
<li><p><code>public Socket accept()</code>侦听并接受到此套接字的连接。此方法在连接传入之前一直阻塞。接受到的Socket和客户端进行通信。</p>
</li>
<li><p><code>public InputStream getInputStream()</code>返回此套接字的输入流。 </p>
</li>
</ul>
</li>
<li><p>步骤</p>
<ul>
<li><p>客户端</p>
<ol>
<li>创建Socket对象,指定要连接的主机和端口</li>
<li>获取socket对象的输出流写入数据,获取输入流接受服务端会写的数据。</li>
</ol>
</li>
<li><p>服务端</p>
<ol>
<li>创建ServerSocket绑定接口</li>
<li>调用accept方法等待连接到来</li>
<li>获取socket中的输入流,读取数据,输出流回写数据。</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
<li><p>网络层封装对象(上面的都是用于传输层)</p>
<ol>
<li><p>URL 封装请求地址对象</p>
<ul>
<li>常用方法<ul>
<li><code>public URL(String spec)</code>:根据 String 表示形式创建 URL 对象。</li>
<li><code>public String getProtocol()</code> 获取此 URL 的协议名称。 </li>
<li><code>public String getHost()</code>获取此 URL 的主机名（如果适用）。</li>
<li><code>public String getPath()</code>获取此 URL 的路径部分。</li>
<li><code>public int getPort()</code>获取此 URL 的端口号。如果未设置端口号，则返回 -1</li>
<li><code>public String getQuery()</code>获取此 URL 的查询部分。</li>
<li><code>public String getFile()</code>:返回的文件部分将与 getPath() 相同，再加上 getQuery() 值的规范化形式（如果有）。</li>
<li><code>public URLConnection openConnection()</code>:返回一个 URLConnection 对象，它表示到 URL 所引用的远程对象的连接。 </li>
<li><code>public final InputStream openStream()</code>此方法是下面方法的缩写:openConnection().getInputStream()</li>
</ul>
</li>
</ul>
</li>
<li><p>URLConnection抽象类,子类:HttpURLConnection</p>
<ul>
<li>常用方法<ul>
<li><code>public InputStream getInputStream()</code>返回从此打开的连接读取的输入流。返回的内容只有响应体,响应头信息可以通过其他get方法获取到。</li>
<li><code>public OutputStream getOutputStream()</code>返回写入到此连接的输出流。</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/01/Java%E7%BD%91%E7%BB%9C/" data-id="ck7eqa14c0016rkubh8hrdumm" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-Java正则" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/25/Java%E6%AD%A3%E5%88%99/" class="article-date">
  <time class="post-time" datetime="2020-02-25T13:45:49.248Z" itemprop="datePublished">
    <span class="post-month">2月</span><br/>
    <span class="post-day">25</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/25/Java%E6%AD%A3%E5%88%99/">Java正则</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Java正则表达式"><a href="#Java正则表达式" class="headerlink" title="Java正则表达式"></a>Java正则表达式</h1><ol>
<li><p>简介</p>
<ul>
<li>作用:专门用于操作字符串</li>
<li>好处:简化对字符串的复杂操作</li>
<li>弊端:符号定义越多,正则越长，阅读性越差</li>
<li>四种功能:匹配/切割/替换/获取</li>
<li>除了获取需要用到Pattern类(正则对象)和Matcher类(正则引擎)其他三种只用String就可以完成。</li>
<li>除了lang包中的String,Pattern类和Matcher类都是java.util.regex包中的</li>
</ul>
</li>
<li><p>常用的符号</p>
<ol>
<li><p>字符</p>
<ul>
<li>x :字符 x </li>
<li>[abc]</li>
<li>[^abc] </li>
<li>[a-z]</li>
<li>[XXXX]:其中任意組合^也可以写在任意前</li>
</ul>
</li>
<li><p>预定义字符类</p>
<ul>
<li>. 任何字符（与行结束符可能匹配也可能不匹配） </li>
<li>\d 数字：[0-9] </li>
<li>\D 非数字： [^0-9]</li>
<li>\s 空白字符：[ \t\n\x0B\f\r] </li>
<li>\S 非空白字符：[^\s]</li>
<li>\w 单词字符：[a-zA-Z_0-9] </li>
<li>\W 非单词字符：[^\w]</li>
</ul>
</li>
<li><p>Greedy 数量词 </p>
<ul>
<li>X? X，零次或一次</li>
<li>X* X，零次或多次 </li>
<li>X+ X，一次或多次 </li>
<li>X{n} X，恰好 n 次 </li>
<li>X{n,} X，至少 n 次 </li>
<li>X{n,m} X，至少 n 次，但是不超过 m 次\</li>
<li>Greedy顾名思义代表贪婪,所有匹配时都会从最大进行匹配,不成功才会往前回溯 。</li>
</ul>
</li>
<li><p>Reluctant 数量词 </p>
<ul>
<li>X?? X，一次或一次也没有 </li>
<li>X*? X，零次或多次 </li>
<li>X+? X，一次或多次 </li>
<li>X{n}? X，恰好 n 次 </li>
<li>X{n,}? X，至少 n 次 </li>
<li>X{n,m}? X，至少 n 次，但是不超过 m 次 </li>
<li>Reluctant顾名思义代表屈服,和Greedy相反谨慎的从最小匹配开始,匹配不成功就贪婪一点。</li>
</ul>
</li>
<li><p>Possessive 数量词 </p>
<ul>
<li>X?+ X，一次或一次也没有 </li>
<li>X*+ X，零次或多次 </li>
<li>X++ X，一次或多次 </li>
<li>X{n}+ X，恰好 n 次 </li>
<li>X{n,}+ X，至少 n 次 </li>
<li>X{n,m}+ X，至少 n 次，但是不超过 m 次</li>
<li>Possessive顾名思义代表占有欲,只能接受最大匹配,最大匹配不行就认为失败。</li>
</ul>
</li>
<li><p>正则中的转义</p>
<ul>
<li>反斜线字符 (‘\‘) 用于引用转义构造，同时还用于引用其他将被解释为非转义构造的字符。</li>
<li>Java 源代码的字符串中的反斜线被解释为转义。因此必须在字符串字面值中使用两个反斜线，表示正则表达式受到保护，不被 Java 字节码编译器解释。</li>
<li>字符串的转义和正则的转义是两种不同的转义。</li>
</ul>
</li>
<li><p>捕获组</p>
<ul>
<li>捕获组可以通过从左到右计算其小括号来编号。组的编号从1开始,组零始终代表整个表达式。</li>
<li>捕获的序列组稍后可以通过 Back 引用在表达式中使用，也可以在匹配操作完成后从匹配器获取。</li>
<li>以 (?) 开头的组是纯的非捕获组,它不捕获文本,也不针对组合计进行计数 </li>
</ul>
</li>
<li><p>Back 引用 </p>
<ul>
<li>\n 任何匹配的 nth 捕获组 </li>
</ul>
</li>
<li><p>边界匹配器 </p>
<ul>
<li>^ 行的开头 </li>
<li>$ 行的结尾 </li>
<li>\b 单词边界 </li>
<li>\B 非单词边界</li>
</ul>
</li>
</ol>
</li>
<li><p>常用的方法</p>
<ol>
<li>String类<ul>
<li><code>boolean matches(String regex)</code>告知此字符串是否匹配给定的正则表达式。 </li>
<li><code>String[] split(String regex)</code>根据给定正则表达式的匹配拆分此字符串。 </li>
<li><code>String replaceAll(String regex,String replacement)</code>使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。 (在replacement获取前面正则表达式的捕获组使用$组号即可。特殊语法,用于替换叠字为单字)</li>
</ul>
</li>
</ol>
</li>
<li><p>获取功能的使用</p>
<ol>
<li><p>将正则表达式封装成正则对象(Pattern)</p>
<ul>
<li><code>static Pattern compile(String regex)</code>将给定的正则表达式编译到模式中。-Pattern</li>
</ul>
</li>
<li><p>将正则对象操作的字符串相关联,获取正则匹配引擎(Matcher)</p>
<ul>
<li><code>Matcher matcher(CharSequence input)</code>创建匹配给定输入与此模式的匹配器。 -Pattern</li>
</ul>
</li>
<li><p>通过引擎对象对符合规则的子串进行操作。(Matcher)</p>
<ul>
<li><p><code>boolean matches()</code>尝试将整个区域与模式匹配。</p>
</li>
<li><p><code>String replaceAll(String replacement)</code>替换模式与给定替换字符串相匹配的输入序列的每个子序列。 </p>
</li>
<li><p><code>boolean find()</code>尝试查找与该模式匹配的输入序列的下一个子序列。 </p>
</li>
<li><p><code>String group()</code>返回由以前匹配操作所匹配的输入子序列。 </p>
</li>
<li><p><code>boolean lookingAt()</code>尝试将从区域开头开始的输入序列与该模式匹配。 </p>
<ul>
<li>与 matches 方法类似，此方法始终从区域的开头开始；与之不同的是，它不需要匹配整个区域。 </li>
</ul>
</li>
<li><p><code>int start()</code>返回以前匹配的初始索引。 </p>
</li>
<li><p><code>int end()</code>返回以前匹配的结束索引。</p>
</li>
<li><p><code>Matcher reset()</code>重置匹配器。 </p>
</li>
</ul>
</li>
<li><p>一个要注意的点</p>
<ul>
<li>matches()/ find()/lookingAt()都会改变匹配引擎的搜索位置,如果先前改变了搜索位置,之后再进行搜索则从先前位置开始,可以调用reset方法重置搜索位置。</li>
</ul>
</li>
</ol>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/02/25/Java%E6%AD%A3%E5%88%99/" data-id="ck7eqa13u000nrkubcr4g08sa" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-Java线程" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/23/Java%E7%BA%BF%E7%A8%8B/" class="article-date">
  <time class="post-time" datetime="2020-02-23T01:58:18.775Z" itemprop="datePublished">
    <span class="post-month">2月</span><br/>
    <span class="post-day">23</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/23/Java%E7%BA%BF%E7%A8%8B/">Java线程</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Java多线程"><a href="#Java多线程" class="headerlink" title="Java多线程"></a>Java多线程</h1><ul>
<li><p>简介</p>
</li>
<li><p>进程是一个正在执行的程序,线程就是进程中的一个独立控制单元,进程中实际运行的模块。一个进程至少要有一个线程</p>
</li>
<li><p>Java中创建线程的两种方式</p>
<ul>
<li><p>继承Thread类</p>
<ul>
<li>该子类应重写 Thread 类的 run 方法。调用该类继承的start方法来开启线程并执行run方法</li>
</ul>
</li>
<li><p>实现Runnable接口</p>
<ul>
<li>定义类实现Runnable接口,覆盖其中的run方法</li>
<li>通过Thread类创建对象并将前一步操作创建的对象传入</li>
<li>调用Thread类的start开启线程</li>
</ul>
</li>
<li><p>只有Thread类和其子类才被称为线程,实现Runnable接口的类并不称为线程</p>
</li>
<li><p>Thread类的常用方法</p>
<ul>
<li><code>void run()</code> Thread 的子类应该重写该方法。 并不会开启线程</li>
<li><code>void start()</code>使该线程开始执行;Java 虚拟机调用该线程的 run 方法。多次启动一个线程是非法的。特别是当线程已经结束执行后，不能再重新启动。</li>
<li><code>Thread(String name)</code>添加线程的名称</li>
<li><code>final String getName()</code>返回该线程的名称。</li>
<li><code>final void setName(String name)</code>改变线程名称，使之与参数 name 相同。 </li>
<li><code>static Thread currentThread()</code>返回对当前正在执行的线程对象的引用。 </li>
<li><code>static void sleep(long millis)throws InterruptedException</code>在指定的毫秒数内让当前正在执行的线程休眠</li>
<li>停止线程 stop方法已经被淘汰,停止线程的的方法只有一种就是run方法结束,多线程的运行代码通常是循环结构,所以控制住循环条件就可以让线程退出。</li>
<li><code>void interrupt()</code>:强制清除wait()方法，或者该类的 join()、sleep(long) 线程冻结状态并且wait(),join(),sleep(long)还将收到一个 InterruptedException。 </li>
<li><code>void setDaemon(boolean on)</code>:将该线程标记为守护线程或用户线程(后台线程)。当正在运行的线程都是守护线程时，Java 虚拟机退出。 该方法必须在启动线程前调用。</li>
<li><code>void join()</code>:当A线程执行到了B线程的join方法时A就会冻结,只有等B执行完后,A线程才能抢夺cpu资源，用于插入新的线程。</li>
<li>优先级<code>final void setPriority(int newPriority)</code></li>
<li><code>static void yield()</code>暂停当前正在执行的线程对象,并执行其他线程,释放cpu执行权。</li>
</ul>
</li>
</ul>
</li>
<li><p>继承Thread和实现Runnable接口的区别?</p>
<ul>
<li>实现方式更加灵活,避免了单继承的局限性</li>
<li>实现方式将线程操作的数据和操作进行了分离,使得可以避免使用静态域。而继承方式将域与执行线程代码绑定在一起,必须使用静态域。写个买票程序就懂了</li>
</ul>
</li>
<li><p>处理多线程安全问题的方法</p>
<ul>
<li><p>安全问题</p>
<ul>
<li>多线程切换的随机性,可能在执行多条语句操作共享数据时出现问题</li>
</ul>
</li>
<li><p>同步代码块</p>
<ul>
<li>synchronized(对象){}:将写在其中的对象称为锁或者监视器通过改变锁的标志位来进行同步操作</li>
</ul>
</li>
<li><p>同步函数</p>
<ul>
<li>返回值类型前加synchronized关键字</li>
<li>加的锁为this</li>
</ul>
</li>
<li><p>同步静态函数</p>
<ul>
<li>返回值类型前加synchronized关键字</li>
<li>加的锁为当前类的字节码对象,在加载类的时候会创建且独一份</li>
</ul>
</li>
<li><p>实现同步的前提</p>
<ul>
<li>必须要有两个或两个以上线程</li>
<li>必须使用同一个锁</li>
</ul>
</li>
<li><p>虽然同步解决了多线程的安全问题,但是增加了操作,消耗了系统资源</p>
</li>
</ul>
</li>
<li><p>多线程在单例设计模式的应用</p>
<ul>
<li><p>饿汉式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Single</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Single s = <span class="keyword">new</span> Single();</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Single</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single <span class="title">getSingle</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<ul>
<li><p>懒汉式(延迟加载)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Single2</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span>  Single2 s = <span class="keyword">null</span>;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Single2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Single2 <span class="title">getSingle</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(s == <span class="keyword">null</span>) </span><br><span class="line">			s = <span class="keyword">new</span> Single2();</span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//效率比上面更高一点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Single3</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span>  Single3 s = <span class="keyword">null</span>;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Single3</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  Single3 <span class="title">getSingle</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(s == <span class="keyword">null</span>) </span><br><span class="line">		<span class="keyword">synchronized</span>(Single3<span class="class">.<span class="keyword">class</span>) </span></span><br><span class="line"><span class="class">		</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(s == <span class="keyword">null</span>) </span><br><span class="line">				s = <span class="keyword">new</span> Single3();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><ul>
<li><p>死锁问题</p>
<ul>
<li>同步在进行嵌套时可能会出现死锁的问题,即使写出死锁的代码,也并不是运行一定会死锁,但是死锁是无法接受的，所以一定要避免。</li>
<li>同步中嵌套同步,但锁不同,一个拿着1号锁要2号锁,一个拿着2号锁要1号锁。</li>
</ul>
</li>
<li><p>线程的五种状态以及转换</p>
<p><img src="D:%5Cblog%5Csource%5Casset%5C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81%E4%BB%A5%E5%8F%8A%E5%88%87%E6%8D%A2%E6%96%B9%E5%BC%8F.jpg" alt=""></p>
</li>
<li><p>线程间通信(等待唤醒机制)</p>
<ul>
<li><p>使用Object类中的(wait/notify/notifyAll)</p>
<ul>
<li><p><code>final void wait()throws InterruptedException</code></p>
</li>
<li><p><code>final void notify()</code></p>
</li>
<li><p>这三个方法都使用在同步中,因为要对持有监视器的线程操作。调用方法的对象为监视器对象,这也是为啥wait/notify/notifyAll方法定义到了Object类中</p>
</li>
<li><p>同一个监视器上的等待线程,只能被同一个监视器上的notify唤醒</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>面对多个生产者/消费者如何保证安全while/notifyAll(重要)</p>
</li>
<li><p>JDK5新特性(java.util.concurrent.locks 包中的Lock/Condition)</p>
<ul>
<li><p><code>Lock</code> 替代了 <code>synchronized</code> 方法和语句的使用，<code>Condition</code>  替代了 Object 监视器方法的使用。 </p>
</li>
<li><p>包含同步块</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">lock.lock();</span><br><span class="line">		<span class="keyword">try</span> </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span>(!flag)</span><br><span class="line">				condition2.await();</span><br><span class="line">			System.out.println(<span class="string">"consume-----"</span>+count);</span><br><span class="line">			flag = <span class="keyword">false</span>;</span><br><span class="line">			condition.signal();</span><br><span class="line">		&#125;<span class="keyword">finally</span> </span><br><span class="line">		&#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Condition</p>
<ul>
<li><code>void await()throws InterruptedException</code>==wait</li>
<li><code>void signal()</code>唤醒一个等待线程。 </li>
<li><code>void signalAll()</code>唤醒所有等待线程。 </li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/02/23/Java%E7%BA%BF%E7%A8%8B/" data-id="ck7eqa13q000drkubcrtc7qys" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-学习开发遇到的单词" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/23/%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E9%81%87%E5%88%B0%E7%9A%84%E5%8D%95%E8%AF%8D/" class="article-date">
  <time class="post-time" datetime="2020-02-23T01:58:01.094Z" itemprop="datePublished">
    <span class="post-month">2月</span><br/>
    <span class="post-day">23</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/23/%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E9%81%87%E5%88%B0%E7%9A%84%E5%8D%95%E8%AF%8D/">学习开发遇到的单词</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/English-Words/">English Words</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li>activation 活化</li>
<li></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/02/23/%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E9%81%87%E5%88%B0%E7%9A%84%E5%8D%95%E8%AF%8D/" data-id="ck7eqa14b0013rkubgx3p1rt6" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/English-Words/" rel="tag">English Words</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-Java常用对象" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/17/Java%E5%B8%B8%E7%94%A8%E5%AF%B9%E8%B1%A1/" class="article-date">
  <time class="post-time" datetime="2020-02-17T14:00:07.396Z" itemprop="datePublished">
    <span class="post-month">2月</span><br/>
    <span class="post-day">17</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/17/Java%E5%B8%B8%E7%94%A8%E5%AF%B9%E8%B1%A1/">Java常用对象</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Java小知识点"><a href="#Java小知识点" class="headerlink" title="Java小知识点"></a>Java小知识点</h1><ol>
<li><p>System(静态工具类)</p>
<ul>
<li><p>定义</p>
<ul>
<li>public final class System<ul>
<li>extends Object</li>
</ul>
</li>
</ul>
</li>
<li><p>方法</p>
<ul>
<li><p><code>static void arraycopy(Object src,int srcPos,Object dest,int destPos,int length);</code>–复制数组</p>
</li>
<li><p><code>static Properties getProperties();</code>获取本机系统的信息</p>
<ul>
<li>例如:file.encoding——GBK,user.country——CN,os.name——Windows 10</li>
<li>实际上返回的Properties可以这么说Properties&lt;String,String&gt;虽然它没泛型,其继承HashTable,虽然HashTable已经被HashMap替代了,但Properties仍然很常用</li>
</ul>
</li>
<li><p><code>static void setProperties(Properties props)</code>:设置本机系统的信息</p>
<ul>
<li>在虚拟机运行java 命令时可以通过添加设置参数来动态设置一些参数信息</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Integer</p>
<ul>
<li><code>public static String toBinaryString(int i);</code></li>
<li><code>public static String toOctalString(int i);</code></li>
<li><code>public static String toHexString(int i);</code></li>
</ul>
</li>
</ol>
<p>3.即使是抽象方法也可以定义构造方法来给子类调用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/02/17/Java%E5%B8%B8%E7%94%A8%E5%AF%B9%E8%B1%A1/" data-id="ck7eqa13j0005rkuba37w21bx" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-JavaIo" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/17/JavaIo/" class="article-date">
  <time class="post-time" datetime="2020-02-17T13:59:49.829Z" itemprop="datePublished">
    <span class="post-month">2月</span><br/>
    <span class="post-day">17</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/17/JavaIo/">JavaIo</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="IO技术-java-io"><a href="#IO技术-java-io" class="headerlink" title="IO技术(java.io)"></a>IO技术(java.io)</h1><ul>
<li><p>Java对数据的操作通过流的方式,用完要将流关闭</p>
</li>
<li><p>分类</p>
<ul>
<li>按操作数据分为字节流和字符流,字符流可以指定编码表</li>
<li>按流向分为输入流和输出流</li>
</ul>
</li>
<li><p>常用基类</p>
<ul>
<li><p>字节流(如果不是指定了缓冲流,字节流并不需要刷新操作,基本用法与字符流相同,就是字符数组变成了字节数组)</p>
<ul>
<li>抽象基类:InputStream,OutputStream</li>
</ul>
</li>
<li><p>字符流</p>
<ul>
<li>抽象基类:Reader,Writer</li>
</ul>
</li>
<li><p>从上述四个基类中派生出的子类名称都是以父类名作为结尾</p>
</li>
</ul>
</li>
<li><p>Writer抽象类</p>
<ul>
<li><p>常用方法</p>
<ul>
<li><code>abstract void write(char[] cbuf, int off, int len) throws IOException</code></li>
<li><code>void write(char[] cbuf) throws IOException</code></li>
</ul>
</li>
<li><p><code>void write(String str) throws IOException</code></p>
<ul>
<li><strong>write方法会写入流的缓冲中,调用flush方法才会刷新,或者用close方法(在关闭前会刷新缓冲)</strong><ul>
<li><code>void flush()  throws IOException</code></li>
<li>``void close()  throws IOException  `</li>
</ul>
</li>
</ul>
</li>
<li><p>子类FileWriter</p>
<ul>
<li><p>构造方法</p>
<ul>
<li><code>FileWriter(String fileName)  throws IOException</code>：:不管原来文件是否存在,都新建文件</li>
<li><code>FileWriter(String fileName,boolean append)  throws IOException</code>：:通过append布尔值来选定是否可以执行续写操作</li>
</ul>
</li>
<li><p>Windows中换行为\r\n 而Linux中\n代表换行</p>
</li>
<li><p>注意<strong>IOException的处理方法:注意要把关闭操作进行判null操作并放在异常处理的finally块中,一定要进行关闭。</strong></p>
</li>
</ul>
</li>
<li><p>子类BufferWriter缓冲字符流(包装流)</p>
<ul>
<li><p>提高封装流对数据的写效率</p>
</li>
<li><p>内部封装了缓冲数组</p>
</li>
<li><p>构造方法:</p>
<ul>
<li><code>BufferedWriter(Writer out);</code></li>
<li><code>BufferedWriter(Writer out,int sz);</code></li>
</ul>
</li>
<li><p>方法</p>
<ul>
<li><code>void newLine() throws IOException</code> :写入一个行分隔符。不同的系统装的JDK时,实现不同从而可以对不同系统换行的兼容</li>
<li><code>void close() throws IOException</code>:会关闭<strong>封装的字符流对象</strong>，因此不用重复关闭传入的流对象</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Reader抽象类</p>
<ul>
<li><p>方法</p>
<ul>
<li><code>int read() throws IOException</code>:读取单个字符,到文件末尾返回-1</li>
<li><code>int read(char[] cbuf) throws IOException</code>:读取到字符数组中(一般设置为1024的整数倍),返回一次读取的字符数,到文件末尾返回-1</li>
<li><code>int read(char[] cbuf,int off,int len);</code></li>
</ul>
</li>
<li><p>子类FileReader</p>
<ul>
<li>构造方法<ul>
<li><code>FileReader(String fileName) throws FileNotFoundException</code></li>
</ul>
</li>
</ul>
</li>
<li><p>子类BufferReader缓冲字符流(包装流)</p>
<ul>
<li><p>提高封装流对数据的读效率</p>
</li>
<li><p>内部封装了缓冲数组</p>
</li>
<li><p>构造方法:</p>
<ul>
<li><code>BufferedReader(Reader in);</code></li>
<li><code>BufferedReader(Reader in,int sz);</code></li>
</ul>
</li>
<li><p>方法:</p>
<ul>
<li><code>String readLine()throws IOException;</code>:读取一个文本行。返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null。<strong>(返回的字符串不包含换行符)</strong></li>
<li><code>void close() throws IOException</code>:会关闭<strong>封装的字符流对象</strong>，因此不用重复关闭传入的流对象</li>
</ul>
</li>
<li><p>子类LineNumberReader(加了行号的缓冲流)</p>
<ul>
<li>public class LineNumberReader<pre><code>extends BufferedReader</code></pre></li>
<li>方法<ul>
<li><code>int getLineNumber();</code>:获取当前行号,没开始时为0,开始就为1</li>
<li><code>void setLineNumber(int lineNumber);</code>:设置当前行号。不会实际更改流中的当前位置,只是更改当前行的标识,增加偏移量</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>InputStream抽象基类(读取)</p>
<ul>
<li><p>一个常用量</p>
<ul>
<li>System.in(InputStream的子类对象)</li>
<li><code>BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));</code></li>
</ul>
</li>
<li><p>方法</p>
<ul>
<li><code>int read() throws IOException</code></li>
<li><code>int read(byte[] b) throws IOException</code></li>
<li><code>int read(byte[] b,int off,int len) throws IOException</code></li>
</ul>
</li>
<li><p>子类</p>
<ul>
<li>FileInputStream</li>
<li>BufferedInputStream<ul>
<li>其中没有readLine方法</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>OutputStream抽象基类(写入)</p>
<ul>
<li><p>方法</p>
<ul>
<li><code>void write(byte[] b);</code></li>
<li><code>void write(byte[] b,int off,int len);</code></li>
</ul>
</li>
<li><p>子类</p>
<ul>
<li>FileOutputStream</li>
<li>BufferedOutputStream<ul>
<li>其中没有newLine方法</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>转换流(将字节输入流转换为字符输入流,将字节输出流转换为字符输出流,可以改变默认编码表)</p>
<ul>
<li><p>InputStreamReader</p>
<ul>
<li><p>定义</p>
<ul>
<li><p>public class InputStreamReader</p>
<p>​    extends Reader</p>
</li>
</ul>
</li>
<li><p>构造方法</p>
<ul>
<li><code>InputStreamReader(InputStream in);</code></li>
<li><code>InputStreamReader(InputStream in,String charsetName) throws UnsupportedEncodingException</code></li>
</ul>
</li>
</ul>
</li>
<li><p>OutputStreamWriter</p>
<ul>
<li><p>定义</p>
<ul>
<li><p>public class OutputStreamWriter</p>
<p>extends Writer</p>
</li>
</ul>
</li>
<li><p>构造方法</p>
<ul>
<li><code>OutputStreamWriter(OutputStream out);</code></li>
<li><code>OutputStreamWriter(OutputStream out,String charsetName) throws UnsupportedEncodingException</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>有关于输入输出流的编码自我理解</p>
<ul>
<li>中间写入的都是字节只是不同编码表对应的字符的字节内容不同,乱码在于展示时使用什么编码去解读这些字节。</li>
</ul>
</li>
<li><p>改变输入输出流的方法</p>
<ul>
<li>使用System类中的方法可以实现<ul>
<li><code>static void setIn(InputStream in);</code></li>
<li><code>static void setOut(PrintStream out);</code></li>
</ul>
</li>
</ul>
</li>
<li><p>异常信息改变打印位置</p>
<ul>
<li><p>使用Throwable类中的方法</p>
<ul>
<li><p><code>void printStackTrace(PrintStream s);</code>将异常信息输出到指定的输出流。</p>
</li>
<li><p><code>void printStackTrace(PrintWriter s);</code>将异常信息输出到指定的 PrintWriter </p>
</li>
</ul>
</li>
<li><p>开发可以使用log4j工具来打印异常</p>
</li>
</ul>
</li>
<li><p>File文件对象(前面的流对象的构造方法也可以使用File对象)</p>
<ul>
<li><p>文件和目录路径名的抽象表示形式,方便对文件和文件夹的属性信息进行操作</p>
</li>
<li><p>字段</p>
<ul>
<li><code>public static final String separator;</code>系统的默认分分隔符保证跨系统</li>
<li>Windows里是\\。</li>
</ul>
</li>
<li><p>构造方法</p>
<ul>
<li><code>public File(String pathname);</code></li>
<li><code>public File(String parent,String child);</code>:将目录和文件分离</li>
</ul>
</li>
<li><p>方法</p>
<ul>
<li><p>创建</p>
<ul>
<li><p><code>boolean createNewFile() throws IOException;</code>:如果指定的文件不存在并成功地创建，则返回 true；如果指定的文件已经存在,不会创建,则返回 false </p>
</li>
<li><p><code>static File createTempFile(String prefix, String suffix,File directory)throws IOException</code></p>
</li>
<li><p><code>static File createTempFile(String prefix,String suffix)
  throws IOException</code></p>
</li>
<li><p><code>boolean mkdir();</code>:创建此抽象路径名指定的目录。 单层目录           </p>
</li>
<li><p><code>boolean mkdirs();</code>:创建此抽象路径名指定的目录，包括所有必需但不存在的父目录。注意，此操作失    败时也可能已经成功地创建了一部分必需的父目录。 </p>
</li>
<li><p>删除(这会直接删除,不能从回收站恢复)</p>
</li>
<li><p><code>boolean delete();</code>:删除此抽象路径名表示的文件或目录。如果此路径名表示一个目录，则该目录必须    为空才能删除。 </p>
</li>
<li><p><code>void deleteOnExit();</code>:在虚拟机终止时，请求删除此抽象路径名表示的文件或目录。</p>
</li>
</ul>
</li>
<li><p>判断</p>
<ul>
<li><p><code>boolean exists();</code>:测试此抽象路径名表示的文件或目录是否存在。 </p>
<ul>
<li><code>boolean canExecute();</code>:测试应用程序是否可以执行此抽象路径名表示的文件。 </li>
<li><code>boolean canRead();</code>:测试应用程序是否可以读取此抽象路径名表示的文件。</li>
<li><code>boolean canWrite()</code>:测试应用程序是否可以修改此抽象路径名表示的文件。 </li>
<li><code>int compareTo(File pathname);</code>按字母顺序比较两个抽象路径名</li>
<li><code>boolean isHidden();</code>测试此抽象路径名指定的文件是否是一个隐藏文件。`</li>
<li><code>boolean isFile();</code>测试此抽象路径名表示的文件是否是一个标准文件。`</li>
<li><code>boolean isDirectory();</code>测试此抽象路径名表示的文件是否是一个目录。 </li>
<li><code>boolean isAbsolute()</code>测试此抽象路径名是否为绝对路径名。</li>
<li>注意:在判断文件的属性时一定要先判断文件或目录本身是否存在</li>
</ul>
</li>
</ul>
</li>
<li><p>获取</p>
<ul>
<li><p><code>String getName()</code>返回由此抽象路径名表示的文件或目录的名称。该名称是路径名名称序列中的最后一个名称。</p>
</li>
<li><p><code>String getPath()==toString()</code>将此抽象路径名转换为一个路径名字符串。</p>
</li>
<li><p><code>String getParent()</code>返回此抽象路径名父目录的路径名字符串；如果此路径名没有指定父目录，则返回 null。</p>
</li>
<li><p><code>String getAbsolutePath()</code>返回此抽象路径名的绝对路径名字符串。</p>
</li>
<li><p><code>long lastModified()</code>返回此抽象路径名表示的文件最后一次被修改的时间。 </p>
</li>
<li><p><code>long length()</code>返回由此抽象路径名表示的文件的长度。以字节为单位；</p>
</li>
<li><p><code>static File[] listRoots();</code>列出可用的文件系统根。 </p>
</li>
<li><p><code>String[] list();</code>返回一个字符串数组，这些字符串指定此抽象路径名表示的目录中的文件和目录。</p>
</li>
<li><p><code>String[] list(FilenameFilter filter);</code> 返回一个字符串数组，这些字符串指定此抽象路径名表示的目录中满足指定过滤器的文件和目录。</p>
</li>
<li><p><code>File[] listFiles()</code>返回一个抽象路径名数组</p>
</li>
<li><p><code>File[] listFiles(FilenameFilter filter)</code>返回抽象路径名数组，这些路径名表示此抽象路径名表示的目录中满足指定过滤器的文件和目录。</p>
</li>
</ul>
</li>
<li><p>重命名</p>
<ul>
<li><code>boolean renameTo(File dest)</code>重新命名此抽象路径名表示的文件。这个操作还可以移动文件</li>
</ul>
</li>
</ul>
</li>
<li><p>列出指定目录下的所有内容(递归)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getLevel</span><span class="params">(<span class="keyword">int</span> level)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">	<span class="keyword">if</span>(level&gt;=<span class="number">1</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		sb.append(<span class="string">"|--"</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;level-<span class="number">1</span>;i++)</span><br><span class="line">			sb.insert(<span class="number">0</span>, <span class="string">"   "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归实现列出指定目录下所有内容</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">practise3</span><span class="params">(File file,<span class="keyword">int</span> level)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	level++;</span><br><span class="line">	File [] files = file.listFiles();</span><br><span class="line">	<span class="keyword">for</span>(File file2: files) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(file2.isDirectory()) </span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(getLevel(level)+file2);</span><br><span class="line">			practise3(file2,level);</span><br><span class="line">		&#125;<span class="keyword">else</span> </span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(getLevel(level)+ file2);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>递归实现删除指定目录下所有内容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeDirOrFile</span><span class="params">(File file)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	File [] files = file.listFiles();</span><br><span class="line">	<span class="keyword">for</span>(File file2: files) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(file2.isDirectory()) </span><br><span class="line">		&#123;</span><br><span class="line">			removeDirOrFile(file2);</span><br><span class="line">			</span><br><span class="line">		&#125;<span class="keyword">else</span> </span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(file2.toString()+<span class="string">"::"</span>+file2.delete());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(file.toString()+<span class="string">"::"</span>+file.delete());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建清单文件列表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fileToList</span><span class="params">(File file,List&lt;File&gt; list)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	File [] files = file.listFiles();</span><br><span class="line">	<span class="keyword">if</span>(files !=<span class="keyword">null</span>)</span><br><span class="line">	<span class="keyword">for</span>(File file2: files) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(file2.isDirectory()) </span><br><span class="line">		&#123;</span><br><span class="line">			fileToList(file2,list);</span><br><span class="line">			</span><br><span class="line">		&#125;<span class="keyword">else</span> </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(file2.getName().endsWith(<span class="string">".py"</span>)) </span><br><span class="line">			&#123;</span><br><span class="line">				list.add(file2);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<ul>
<li><p>Properties对象</p>
<ul>
<li><p>简介</p>
<ul>
<li>public class Properties extends Hashtable&lt;Object,Object&gt;</li>
<li>Properties 类表示了一个持久的属性集。Properties 可保存在流中或从流中加载。<br>属性列表中每个键及其对应值都是一个字符串。 此类是线程安全的：多个线程可以共享单个 Properties 对象而无需进行外部同步。</li>
<li>在properties的配置文件中#代表单行注释信息</li>
</ul>
</li>
<li><p>构造函数和方法</p>
<ul>
<li><code>Properties()</code>创建一个无默认值的空属性列表。</li>
<li><code>void list(PrintStream out)</code>将属性列表输出到指定的输出流。 </li>
<li><code>void list(PrintWriter out)</code>将属性列表输出到指定的输出流。</li>
<li><code>void load(InputStream inStream)throws IOException</code>从输入流中读取属性列表（键和元素对）。</li>
<li><code>void load(Reader reader)throws IOException</code>按简单的面向行的格式从输入字符流中读取属性列表（键和元素对）。jdk1.6</li>
<li><code>Set&lt;String&gt; stringPropertyNames()</code>返回此属性列表中的键集</li>
<li><code>void store(Writer writer,String comments) throws IOException</code>将此 Properties 表中的属性列表（键和元素对）写入输出字符。 </li>
<li><code>void store(OutputStream out,String comments)throws IOException</code>将此 Properties 表中的属性列表（键和元素对）写入输出流。</li>
</ul>
</li>
</ul>
</li>
<li><p>打印流(printStream/printWriter[构造函数字节字符流都可以])</p>
<ul>
<li><p>简介</p>
<ul>
<li>为其他输出流添加了功能，使它们能够方便地打印各种数据值表示形式。可以指定<strong>自动刷新和编码集操作</strong></li>
<li>print,printf，println等相关方法</li>
</ul>
</li>
<li><p>PrintStream构造函数可接受的类型</p>
<ul>
<li>File</li>
<li>字符串路径String</li>
<li><strong>字节输出流OutputStream</strong></li>
</ul>
</li>
<li><p>PrintWriter构造函数可接受的类型</p>
<ul>
<li>File</li>
<li>字符串路径String</li>
<li><strong>字节输出流OutputStream</strong></li>
<li><strong>字符输出流Writer</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>序列流(合并字节输入流)</p>
<ul>
<li><p>简介</p>
<ul>
<li>SequenceInputStream 表示其他输入流的逻辑串联。</li>
<li>它从输入流的有序集合开始，并从第一个输入流开始读取，直到到达文件末尾，接着从第二个输入流读取，依次类推，直到到达包含的最后一个输入流的文件末尾为止。 </li>
</ul>
</li>
<li><p>构造方法</p>
<ul>
<li><code>SequenceInputStream(InputStream s1,InputStream s2);</code></li>
<li><code>SequenceInputStream(Enumeration&lt;? extends InputStream&gt; e)</code>通过枚举参数来初始化新创建的 SequenceInputStream。</li>
</ul>
</li>
<li><p>Java并未提供切割文件保存的方式,可以自己实现</p>
</li>
</ul>
</li>
<li><p>对象流</p>
<ul>
<li><p>对象的本地序列化</p>
<ul>
<li>操作的对象必须实现java.io.Serializable接口</li>
<li>只能序列化堆中的内容,并不能序列化静态,如果不想被序列化  可以加上transient(瞬时)</li>
<li>一般存成的序列化文件为xxx.object</li>
</ul>
</li>
<li><p>ObjectInputStream</p>
<ul>
<li><code>ObjectInputStream(InputStream in)throws IOException</code></li>
<li><code>Object readObject()throws IOException,ClassNotFoundException</code>从 ObjectInputStream 读取对象。一次读一个对象</li>
</ul>
</li>
<li><p>ObjectOutputStream</p>
<ul>
<li><code>ObjectOutputStream(OutputStream out)throws IOException</code></li>
<li><code>final void writeObject(Object obj)throws IOException</code>将指定的对象写入 ObjectOutputStream。</li>
</ul>
</li>
</ul>
</li>
<li><p>管道流(用于多线程中)</p>
<ul>
<li><p>PipedInputStream/PipedOutputStream(有对应的Reader/Writer的类),输入输出直接对接在一起,结合线程使用,因为如果单线程使用会导致死锁的发生。</p>
</li>
<li><p>管道输入流应该连接到管道输出流；管道输入流提供要写入管道输出流的所有数据字节。</p>
<p>通常，数据由某个线程从 PipedInputStream 对象读取，并由其他线程将其写入到相应的 PipedOutputStream。</p>
</li>
<li><p>用途:多线程之间进行通信</p>
</li>
<li><p>PipedInputStream</p>
<ul>
<li>构造方法和普通方法<ul>
<li><code>public PipedInputStream()</code>创建尚未连接的 PipedInputStream。</li>
<li><code>public PipedInputStream(PipedOutputStream src)</code>创建 PipedInputStream，使其连接到管道输出流 src。</li>
<li><code>public void connect(PipedOutputStream src)</code>使此管道输入流连接到管道输出流 src。</li>
</ul>
</li>
</ul>
</li>
<li><p>PipedOutputStream</p>
<ul>
<li>构造方法和普通方法<ul>
<li><code>public PipedOutputStream()</code>创建尚未连接到管道输入流的管道输出流。</li>
<li><code>public PipedOutputStream(PipedInputStream snk)</code>创建连接到指定管道输入流的管道输出流。</li>
<li><code>public void connect(PipedInputStream snk)</code>将此管道输出流连接到接收者。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>随机读写文件( RandomAccessFile)</p>
<ul>
<li><p>简介</p>
<ul>
<li>只继承Object和其他流不同</li>
<li>内部封装字节流,文件中提供字节指针来进行随机访问</li>
<li>可以读和写</li>
</ul>
</li>
<li><p>构造方法</p>
<ul>
<li><code>RandomAccessFile(File file,String mode);</code></li>
<li><code>RandomAccessFile(String name,String mode);</code></li>
<li>mode解释<ul>
<li>“r” 以只读方式打开。调用结果对象的任何 write 方法都将导致抛出 IOException。  文件不存在会抛出异常</li>
<li>“rw” 打开以便读取和写入。如果该文件尚不存在，则尝试创建该文件。 文件存在则使用和输出流不同 </li>
</ul>
</li>
</ul>
</li>
<li><p>常用方法</p>
<ul>
<li><code>void seek(long pos)</code>设置到此文件开头测量到的文件指针偏移量，在该位置发生下一个读取或写入操作。–任意跳</li>
<li><code>int skipBytes(int n)</code>尝试跳过输入的 n 个字节以丢弃跳过的字节。 –只能向后跳</li>
<li>有各种类型的write/read方法</li>
</ul>
</li>
<li><p>用途</p>
<ul>
<li>实现数据的多线程分段下载</li>
</ul>
</li>
</ul>
</li>
<li><p>操作基本数据类型的流(DataInputStream/DataOutputStream)</p>
<ul>
<li><p>将流和基本数据类型结合在一起</p>
</li>
<li><p>DataInputStream</p>
<ul>
<li><code>public DataInputStream(InputStream in)</code>使用指定的底层 InputStream 创建一个 DataInputStream。 </li>
<li><code>public readXXX();</code></li>
<li><code>static final String readUTF(DataInput in)</code>从流 in 中读取用 UTF-8 修改版格式编码的 Unicode 字符格式的字符串；( UTF-8 修改版和UTF-8不一样)</li>
</ul>
</li>
<li><p>​    DataOutputStream</p>
<ul>
<li><code>public DataOutputStream(OutputStream out)</code>创建一个新的数据输出流，将数据写入指定基础输出流。</li>
<li><code>final void writeUTF(String str)</code>以与机器无关方式使用 UTF-8 修改版编码将一个字符串写入基础输出流。 ( UTF-8 修改版和UTF-8不一样)</li>
</ul>
</li>
</ul>
</li>
<li><p>操作数组(字节/字符)/字符串的对象—先从硬盘读取数据到内存(再从内存读取数据将数据写到自定义的内存数组中)</p>
<ul>
<li><p>ByteArrayInputStream/ByteArrayOutputStream</p>
<ul>
<li>ByteArrayInputStream<ul>
<li>ByteArrayInputStream 包含一个内部缓冲区，该缓冲区包含从流中读取的字节。内部计数器跟踪 read 方法要提供的下一个字节。 关闭 ByteArrayInputStream 无效。此类中的方法在关闭此流后仍可被调用，而不会产生任何 IOException。(因为操作的是内存和文件毫无关系) </li>
<li><code>public ByteArrayInputStream(byte[] buf)</code>创建一个 ByteArrayInputStream，使用 buf 作为其缓冲区数组。</li>
</ul>
</li>
<li>ByteArrayOutputStream<ul>
<li>此类实现了一个输出流，其中的数据被写入一个 byte 数组。缓冲区会随着数据的不断写入而自动增长。可使用 toByteArray() 和 toString() 获取数据。 关闭此流无效。此类中的方法在关闭此流后仍可被调用，而不会产生任何 IOException。</li>
<li><code>public ByteArrayOutputStream()</code>创建一个新的 byte 数组输出流。缓冲区的容量最初是 32 字节，如有必要可增加其大小。</li>
</ul>
</li>
</ul>
</li>
<li><p>操作字符数组的对象CharArrayInputStream/CharArrayOutputStream</p>
</li>
<li><p>操作字符串的对象StringReader/StringWriter</p>
</li>
<li><p>和操作字节数组的对象基本一样</p>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/02/17/JavaIo/" data-id="ck7eqa13f0001rkub5ado8mgv" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-JavaString" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/15/JavaString/" class="article-date">
  <time class="post-time" datetime="2020-02-15T14:47:52.345Z" itemprop="datePublished">
    <span class="post-month">2月</span><br/>
    <span class="post-day">15</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/15/JavaString/">JavaString</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="String对象"><a href="#String对象" class="headerlink" title="String对象"></a>String对象</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><p>public final class String<br>      extends Object<br>      implements Serializable, Comparable<String>, CharSequence</p>
<ol>
<li>一旦被初始化就不能改变</li>
<li>String s1 = “abc”;和String s2 = new String(“abc”);区别<ul>
<li>前者只创建一个对象,后者创建两个对象</li>
</ul>
</li>
</ol>
<h3 id="2-常用方法"><a href="#2-常用方法" class="headerlink" title="2.常用方法"></a>2.常用方法</h3><ol>
<li><p>获取</p>
<p>1.1 字符串长度</p>
<ul>
<li><code>int length();</code></li>
</ul>
<p>1.2 根据位置获取字符</p>
<ul>
<li><code>char charAt(int index);</code></li>
</ul>
<p>1.3 根据字符/字符串获取第一个位置</p>
<ul>
<li><pre><code class="java">                      <span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> ch)</span></span>;
                       <span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> ch,<span class="keyword">int</span> fromIndex)</span></span>;
                        <span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span></span>;
                        <span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str,<span class="keyword">int</span> fromIndex)</span></span>;
                        <span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(<span class="keyword">int</span> ch)</span></span>;
                       <span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(<span class="keyword">int</span> ch,<span class="keyword">int</span> fromIndex)</span></span>;
                       <span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(String str)</span></span>;
                       <span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(String str,<span class="keyword">int</span> fromIndex)</span></span>;
&lt;!--￼<span class="number">0</span>--&gt;


</code></pre>
</li>
</ul>
</li>
</ol>
<p>   3.2 将基本数据类型和char[]转换成字符串</p>
<ul>
<li><code>static String valueOf(dateType data);</code></li>
</ul>
<p>   3.3 将字符串转换为字符数组</p>
<ul>
<li><code>char[] toCharArray();</code></li>
</ul>
<p>   3.4 字节数组转换为字符串</p>
<ul>
<li><code>String(byte[] bytes);</code></li>
<li><code>String(byte[] bytes, int offset, int length);</code></li>
</ul>
<p>   3.5 字符串转换成字节数组</p>
<ul>
<li><code>byte[] getBytes();</code></li>
</ul>
<p>   3.6 把字符串转换成大写/小写</p>
<ul>
<li><code>String toLowerCase();</code></li>
<li><code>String toUpperCase();</code></li>
</ul>
<ul>
<li>特殊之处:字符串和字节数组转换过程中,可以指定编码表,所以在处理编码问题时可以以此来进行转换。</li>
</ul>
<ol start="4">
<li><p>替换</p>
<ul>
<li><code>String replace(char oldChar,char newChar);</code></li>
<li><code>String replace(CharSequence target,CharSequence replacement);</code></li>
</ul>
</li>
<li><p>切割</p>
<ul>
<li><code>String[] split(String regex);</code></li>
</ul>
</li>
<li><p>子串</p>
<ul>
<li><code>String substring(int beginIndex);</code></li>
<li><code>String substring(int beginIndex,int endIndex);</code></li>
</ul>
</li>
<li><p>去除空格,比较</p>
<ul>
<li><p><code>String trim();</code>–忽略前导空白和尾部空白</p>
</li>
<li><p><code>int compareTo(String anotherString);</code></p>
</li>
</ul>
</li>
</ol>
<h3 id="3-StringBuffer-缓冲区容器对象-jdk1-0"><a href="#3-StringBuffer-缓冲区容器对象-jdk1-0" class="headerlink" title="3.StringBuffer(缓冲区容器对象):jdk1.0"></a>3.StringBuffer(缓冲区容器对象):jdk1.0</h3><ol>
<li><p>简介</p>
<ul>
<li><p>public final class StringBuffer</p>
<ul>
<li>extends Object<ul>
<li>implements Serializable, CharSequence</li>
</ul>
</li>
</ul>
</li>
<li><p>线程安全的可变字符序列。</p>
</li>
<li><p>本身是一个容器，创建以后始终只有一个容器对象,本身并不会新建容器对象。</p>
</li>
</ul>
</li>
<li><p>常用构造方法</p>
<ul>
<li>StringBuffer()<br>构造一个其中不带字符的字符串缓冲区，其初始容量为 16 个字符。</li>
<li>StringBuffer(String str);</li>
</ul>
</li>
</ol>
<p>3.常用方法</p>
<ol>
<li><p>存储</p>
<ul>
<li><code>StringBuffer append(dataType data);</code></li>
<li><code>StringBuffer insert(int offset,dataType data);</code></li>
</ul>
</li>
<li><p>删除</p>
<ul>
<li><code>StringBuffer delete(int start,int end);</code></li>
<li><code>StringBuffer deleteCharAt(int index);</code></li>
</ul>
</li>
<li><p>获取</p>
<ul>
<li><pre><code class="java"><span class="function"><span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span></span>;
<span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;
<span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span></span>;
 <span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str,<span class="keyword">int</span> fromIndex)</span></span>;
 <span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(String str)</span></span>;
 <span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(String str,<span class="keyword">int</span> fromIndex)</span></span>;
<span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> start)</span></span>;
 <span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>;
 <span class="function"><span class="keyword">void</span> <span class="title">getChars</span><span class="params">(<span class="keyword">int</span> srcBegin,<span class="keyword">int</span> srcEnd,<span class="keyword">char</span>[] dst,<span class="keyword">int</span> dstBegin)</span></span>;</code></pre>
</li>
</ul>
</li>
</ol>
<ol start="4">
<li><p>修改</p>
<ul>
<li><code>void setCharAt(int index,char ch);</code></li>
<li><code>StringBuffer replace(int start,int end, String str);</code></li>
</ul>
</li>
<li><p>反转</p>
<ul>
<li><code>StringBuffer reverse();</code></li>
</ul>
</li>
</ol>
<h3 id="4-StringBuilder-jdk1-5"><a href="#4-StringBuilder-jdk1-5" class="headerlink" title="4.StringBuilder  jdk1.5"></a>4.StringBuilder  jdk1.5</h3><ol>
<li><p>简介</p>
<ul>
<li><p>public final class StringBuilder</p>
<ul>
<li>extends Object<ul>
<li>implements Serializable, CharSequence</li>
</ul>
</li>
</ul>
</li>
<li><p>一个可变的字符序列。该类被设计用作 StringBuffer 的一个简易替换,不保证同步。单线程时效率高。</p>
</li>
</ul>
</li>
</ol>
<h3 id="5-Java在升级时的三个要素"><a href="#5-Java在升级时的三个要素" class="headerlink" title="5.  Java在升级时的三个要素"></a>5.  Java在升级时的三个要素</h3><ol>
<li>提高效率(StringBuilder)</li>
<li>简化书写(泛型)</li>
<li>提高安全性 </li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/02/15/JavaString/" data-id="ck7eqa13k0006rkub65ix7k5i" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-eclipse常用快捷键" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/14/eclipse%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/" class="article-date">
  <time class="post-time" datetime="2020-02-14T14:08:02.403Z" itemprop="datePublished">
    <span class="post-month">2月</span><br/>
    <span class="post-day">14</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/14/eclipse%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/">eclipse常用快捷键</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/eclipse/">eclipse</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li>ctrl+o:提供类中域和方法的outline</li>
<li>crtl+shift+t:提供搜索的视窗</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/02/14/eclipse%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/" data-id="ck7eqa14g001hrkub75ox958w" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/eclipse/" rel="tag">eclipse</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-Java继承" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/12/Java%E7%BB%A7%E6%89%BF/" class="article-date">
  <time class="post-time" datetime="2020-02-12T03:38:09.705Z" itemprop="datePublished">
    <span class="post-month">2月</span><br/>
    <span class="post-day">12</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/12/Java%E7%BB%A7%E6%89%BF/">Java继承</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Java继承"><a href="#Java继承" class="headerlink" title="Java继承"></a>Java继承</h2><ol>
<li><p>方法覆盖(重写)</p>
<ul>
<li><p>注意事项</p>
<ol>
<li>子类覆盖父类方法保证权限大于等于父类</li>
<li><strong>静态方法只能被静态方法隐藏</strong></li>
</ol>
</li>
<li><p>重写和重载的区别</p>
<ol>
<li>重载:只看同名函数的参数列表</li>
<li>子父类方法要一模一样(除了多态下返回类型可以用子父类兼容)</li>
</ol>
</li>
</ul>
</li>
<li><p>继承下的构造函数</p>
<ol>
<li>构造函数函数名一定不同,不可能出现覆盖</li>
<li>子类构造函数默认会调用空参构造函数(super()),如果显示调用了父类构造函数,则不会隐式调用,调用构造器的语句只能在构造器函数的第一行</li>
<li>因为this构造器调用也要写在第一行,所以如果第一行写了this语句也不会存在隐式调用super语句,其实调用的其他本类构造函数一定调用了父类的构造函数(隐式或者显式)</li>
</ol>
</li>
<li><p>final关键字</p>
<ol>
<li>final修饰的类不能被继承</li>
<li>final修饰的函数不能被重写</li>
<li>final修饰的变量值不能改变且必须初始化,既可以修饰成员变量也可以修饰局部变量(名称全大写多个单词间加_),这样可以增强阅读性,推荐使用</li>
<li>内部类定义在类的局部位置上时,只能访问该局部被final修饰的局部变量</li>
</ol>
</li>
<li><p>Java方法和变量在继承中的覆盖和隐藏</p>
<ol>
<li><p>父类的实例变量和静态变量能被子类的同名变量<strong>隐藏</strong> </p>
</li>
<li><p>父类的静态方法被子类的同名静态方法<strong>隐藏</strong> </p>
</li>
<li><p>父类的实例方法被子类的同名实例变量<strong>覆盖</strong> </p>
<p>注意:</p>
<ul>
<li>不能用子类的静态方法<strong>隐藏</strong> 父类中同样标示（也就是返回值 名字 参数都一样）的实例方法 </li>
<li>不能用子类的实例方法<strong>覆盖</strong> 父类中同样标示的静态方法 </li>
<li>变量只会被<strong>隐藏</strong> 不会被<strong>覆盖</strong> ，无论他是实例变量还是静态变量，而且，子类的静态变量可以<strong>隐藏</strong> 父类的实例变量，子类的实例变量可以<strong>隐藏</strong> 父类的静态变量 </li>
<li><strong>隐藏</strong> 和<strong>覆盖</strong> 的区别在于，子类对象转换成父类对象后，能够访问父类被<strong>隐藏</strong> 的变量和方法，而不能访问父类被<strong>覆盖</strong> 的方法 </li>
</ul>
</li>
</ol>
</li>
<li><p>接口(interface)</p>
<ol>
<li><p>public static final  域</p>
</li>
<li><p>public abstract  方法</p>
</li>
<li><p>接口被类多实现,接口与接口之间存在多继承</p>
</li>
<li><p>抽象类与接口的不同点</p>
<ul>
<li>抽象类用于对对象的共性抽取(基本功能)用继承拿到</li>
<li>接口用于对类的功能扩展,使用实现来扩展(扩展功能)</li>
</ul>
</li>
<li><p>jdk1.8引入的新功能</p>
<ul>
<li>接口中可以定义静态函数</li>
<li>接口的抽象函数可以通过default关键字为抽象方法提供一种默认实现(写了default就不用abstract了)</li>
</ul>
</li>
</ol>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/02/12/Java%E7%BB%A7%E6%89%BF/" data-id="ck7eqa14d001arkubag1k0ggq" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>
  
</article>




  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">next &amp;raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <h1 class="blog-title">little Blog</h1>
    <h2 class="blog-subtitle"></h2>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/categories" title="Categories">
            <li>分类</li>
          </a>
        
          <a href="/tags" title="Tags">
            <li>标签</li>
          </a>
        
    </ul>
  </div>
</div>

  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="https://wx4.sinaimg.cn/large/a3ba40b9ly1gbifs44zi0j20p00p0ac3.jpg">
    <h2 class="author">Yang Nan</h2>
    <h3 class="description"></h3>
    <div class="count-box">
      <a href="/archives"><div><strong>18</strong><br>文章</div></a>
      <a href="/categories"><div><strong>4</strong><br>分类</div></a>
      <a href="/tags"><div><strong>6</strong><br>标签</div></a>
    </div>



    <div class="social-link">
      
        <a class="hvr-bounce-in" href="https://github.com/kiritonan" target="_blank" title="Github">
          Github
        </a>
      
    </div>

    <div class="friend-link">
      <h2>友情链接</h2>
      
        <a class="hvr-bounce-in" href="http://blog.shanamaid.top/" target="_blank" title="ShanaMaid">
          ShanaMaid
        </a>
      
    </div>
  </div>
</div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy;2019 - 2020 Yang Nan<br>
      由<a href="http://hexo.io/" target="_blank">Hexo</a>强力驱动 | 
      主题-<a href="https://github.com/ShanaMaid/hexo-theme-shana" target="_blank" rel="noopener">Shana</a>
      
    </div>
    
  </div>
</footer>
    </div>
    

<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script src="//apps.bdimg.com/libs/wow/0.1.6/wow.min.js"></script>
<script>
new WOW().init();
</script>   


  
<link rel="stylesheet" href="/plugin/fancybox/jquery.fancybox.css">

  
<script src="/plugin/fancybox/jquery.fancybox.pack.js"></script>




  
<link rel="stylesheet" href="/plugin/galmenu/GalMenu.css">

  
<script src="/plugin/galmenu/GalMenu.js"></script>

  <div class="GalMenu GalDropDown">
      <div class="circle" id="gal">
        <div class="ring">
          
            <a href="/" title="" class="menuItem">首页</a>
          
            <a href="/tags" title="" class="menuItem">标签</a>
          
            <a href="/categories" title="" class="menuItem">分类</a>
          
            <a href="/archives" title="" class="menuItem">归档</a>
          
            <a href="/xxxxxxxxx" title="" class="menuItem">xxx</a>
          
            <a href="/xxxxxxx" title="" class="menuItem">xxxx</a>
          
        </div>
        
          <audio id="audio" src="#"></audio>
        
      </div> 
</div>
<div id="overlay" style="opacity: 1; cursor: pointer;"></div>
  <script type="text/javascript">var items = document.querySelectorAll('.menuItem');
    for (var i = 0,
    l = items.length; i < l; i++) {
      items[i].style.left = (50 - 35 * Math.cos( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%";
      items[i].style.top = (50 + 35 * Math.sin( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%"
    }</script>
<script type="text/javascript">
  $(document).ready(function() {
    $('body').GalMenu({
      'menu': 'GalDropDown'
    })
  });
</script>

  <section class="hidden-xs"> 
  <ul class="cb-slideshow"> 
    <li><span>苟利</span></li> 
    <li><span>国家</span></li> 
    <li><span>生死以</span></li> 
    <li><span>岂能</span></li> 
    <li><span>祸福</span></li> 
    <li><span>趋避之</span></li> 
  </ul>
</section>

<script src="/js/script.js"></script>




  </div>
</body>
</html>